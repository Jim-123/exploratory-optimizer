#include "aqo.h"
/*****************************************************************************
 *
 *	PLAN GENERATION
 *
 * This is the module in which plan can be generated by consider both
 * cost and explore_value. 
 *
 *****************************************************************************/


RelOptInfo *
aqo_join_search(PlannerInfo *root, int levels_needed, List *initial_rels)
{
	int			lev;
	RelOptInfo *rel;

	/*
	 * This function cannot be invoked recursively within any one planning
	 * problem, so join_rel_level[] can't be in use already.
	 */
	Assert(root->join_rel_level == NULL);
	/*modified by jim in 2022.7.4, copy best_estimated_cost of query*/
	root->best_estimate_cost_of_current_query = query_context.best_pred_cost;
	/*
	 * We employ a simple "dynamic programming" algorithm: we first find all
	 * ways to build joins of two jointree items, then all ways to build joins
	 * of three items (from two-item joins and single items), then four-item
	 * joins, and so on until we have considered all ways to join all the
	 * items into one rel.
	 *
	 * root->join_rel_level[j] is a list of all the j-item rels.  Initially we
	 * set root->join_rel_level[1] to represent all the single-jointree-item
	 * relations.
	 */
	root->join_rel_level = (List **) palloc0((levels_needed + 1) * sizeof(List *));

	root->join_rel_level[1] = initial_rels;

	for (lev = 2; lev <= levels_needed; lev++)
	{
		ListCell   *lc;

		/*
		 * Determine all possible pairs of relations to be joined at this
		 * level, and build paths for making each one from every available
		 * pair of lower-level relations.
		 */
		join_search_one_level(root, lev);

		/*
		 * Run generate_gather_paths() for each just-processed joinrel.  We
		 * could not do this earlier because both regular and partial paths
		 * can get added to a particular joinrel at multiple times within
		 * join_search_one_level.  After that, we're done creating paths for
		 * the joinrel, so run set_cheapest().
		 */
		foreach(lc, root->join_rel_level[lev])
		{
			rel = (RelOptInfo *) lfirst(lc);

			/* Create GatherPaths for any useful partial paths for rel */
			generate_gather_paths(root, rel);

			/*choose corresponding set function*/
            if(root->search_plan_mode==0){
				set_cheapest(rel);
			}else
			{
				/* Find and save the cheapest paths for this rel */
				set_cheapest_explore(rel);
			}

#ifdef OPTIMIZER_DEBUG
			debug_print_rel(root, rel);
#endif
		}
	}

	if (root->join_rel_level[levels_needed] == NIL)
		elog(ERROR, "failed to build any %d-way joins", levels_needed);
	Assert(list_length(root->join_rel_level[levels_needed]) == 1);

	rel = (RelOptInfo *) linitial(root->join_rel_level[levels_needed]);

	root->join_rel_level = NULL;
    
	
	return rel;
}
/**
 * add explore value to path
 */
void aqo_set_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte)
{
    ListCell   *p;
	/*decide the plan search mode*/
	if (aqo_mode == AQO_MODE_DISABLED){
		root->search_plan_mode = 0;
	}else
	{
		root->search_plan_mode = 2;
		/* Finally, we need to transform the rate_to_generate_explore_plan value to root. Modified by jim*/
		root->rate_to_generate_explore_plan = rate_to_generate_explore_plan;
		/* the rate between estimate cost and true cost*/
		root->rate_to_compare_best_est_cost = rate_to_compare_best_est_cost;
		root->prune_rate_for_add_path_explore = prune_rate_for_add_path_explore;
	}
}

/* copy the estimate cost to query_context*/
void aqo_estimated_cost_hook(Path *path){
	query_context.best_est_cost = path->total_cost;
}

/**
 * calculate best estimate cost of current query
 * add by jim 2021.3.11, modified by jim in 2022.7.4
 * */
//void calculate_current_best_estimate_cost(PlannerInfo *root, int query_pattern, int nfeatures, double *input_feature)
void calculate_current_best_estimate_cost(QueryContextData	*query_context2, int query_pattern, int nfeatures, double *input_feature)
{
	//1. define and palloc the require matrix and vector
	double **feature_matrix;
	double *best_est_costs;
	double *best_true_costs;
	int i,k;
	double  est_best_cost = 0;
	int     rows;
	feature_matrix = palloc(sizeof(*feature_matrix) * num_two_costs_save);
	for (i = 0; i < num_two_costs_save; ++i)
		feature_matrix[i] = palloc0(sizeof(**feature_matrix) * nfeatures);
	best_est_costs = palloc0(sizeof(*best_est_costs) * num_two_costs_save);
	best_true_costs = palloc0(sizeof(*best_true_costs) * num_two_costs_save);
	//2. load the current features and two costs. rows = 0 indicate the table have no history data of this query_pattern
	if(!load_best_two_costs(query_pattern, feature_matrix, best_est_costs, best_true_costs, &rows, nfeatures))
		rows = 0;
	//3. predict the best estimated cost
	est_best_cost = OkNNr_predict2(rows, nfeatures,
			  feature_matrix, best_est_costs,
			  input_feature, 2);
	query_context2->best_pred_cost = est_best_cost;
	//4. free the memory
	for (k = 0; k < num_two_costs_save; ++k)
      pfree(feature_matrix[k]);
   pfree(feature_matrix);
   pfree(best_est_costs);
   pfree(best_true_costs);
}

/**
 * update best estimate and true costs of current query
 * add by jim 2021.3.11
 * */
void update_two_best_costs_record(int current_query_pattern, int nfeatures, double *current_query_features, Cost best_est_cost, double total_time)
{
	//1. define and palloc the require matrix and vectors
	double **feature_matrix;
	double *best_est_costs;
	double *best_true_costs;
	int     i,k;
	int     rows;
	int     new_matrix_rows;
	List   *changed_lines = NIL;
	ListCell   *l;
    feature_matrix = palloc(sizeof(*feature_matrix) * num_two_costs_save);
	for (i = 0; i < num_two_costs_save; ++i)
		feature_matrix[i] = palloc0(sizeof(**feature_matrix) * nfeatures);
	best_est_costs = palloc0(sizeof(*best_est_costs) * num_two_costs_save);
	best_true_costs = palloc0(sizeof(*best_true_costs) * num_two_costs_save);
    //2. load the current features and two costs. rows = 0 indicate the table have no history data of this query_pattern
	if(!load_best_two_costs(current_query_pattern, feature_matrix, best_est_costs, best_true_costs, &rows, nfeatures))
		rows = 0;
	//3. update
   changed_lines = OkNNr_learn2(rows, nfeatures,
                        feature_matrix, best_est_costs, best_true_costs,
                        current_query_features, best_est_cost, total_time, num_two_costs_save);

   new_matrix_rows = rows;
   foreach(l, changed_lines)
   {
      if (lfirst_int(l) >= new_matrix_rows)
         new_matrix_rows = lfirst_int(l) + 1;
   }
   //4. 将数据写入表中
   update_best_two_costs(current_query_pattern, nfeatures, new_matrix_rows, feature_matrix, best_est_costs, best_true_costs);
   //释放内存
   for (k = 0; k < num_two_costs_save; ++k)
      pfree(feature_matrix[k]);
   pfree(feature_matrix);
   pfree(best_est_costs);
   pfree(best_true_costs);
}